<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProEdit - Advanced Universal Editor</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: white;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.08);
            border-left: 5px solid #2563eb;
        }

        .header h1 {
            color: #2563eb;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 28px;
        }

        .upload-box {
            border: 3px dashed #2563eb;
            padding: 50px;
            text-align: center;
            background: linear-gradient(135deg, #eff6ff 0%, #e0f2fe 100%);
            border-radius: 12px;
            cursor: pointer;
            margin-bottom: 25px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .upload-box:hover {
            background: linear-gradient(135deg, #dbeafe 0%, #bae6fd 100%);
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(37, 99, 235, 0.15);
        }

        .upload-box i {
            font-size: 48px;
            color: #2563eb;
            margin-bottom: 15px;
        }

        input[type="file"] {
            display: none;
        }

        .editor-grid {
            display: grid;
            grid-template-columns: 450px 1fr;
            gap: 25px;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .controls {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.08);
            height: fit-content;
            position: sticky;
            top: 25px;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: #1f2937;
            font-size: 15px;
        }

        .control-group input[type="text"],
        .control-group textarea,
        .control-group select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            transition: border 0.3s ease;
        }

        .control-group input:focus,
        .control-group textarea:focus,
        .control-group select:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .control-group textarea {
            min-height: 120px;
            resize: vertical;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            padding: 14px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 15px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:hover {
            background: #1d4ed8;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: #6b7280;
        }

        button.secondary:hover {
            background: #4b5563;
        }

        button.success {
            background: #10b981;
        }

        button.success:hover {
            background: #059669;
        }

        button.danger {
            background: #ef4444;
        }

        button.danger:hover {
            background: #dc2626;
        }

        button.warning {
            background: #f59e0b;
        }

        button.warning:hover {
            background: #d97706;
        }

        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .content {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.08);
            min-height: 700px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 10px;
        }

        .tab {
            padding: 12px 24px;
            background: #f3f4f6;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .tab.active {
            background: #2563eb;
            color: white;
        }

        .tab:hover:not(.active) {
            background: #e5e7eb;
        }

        .text-editor {
            width: 100%;
            min-height: 650px;
            padding: 25px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            background: #fafafa;
        }

        .text-editor:focus {
            outline: none;
            border-color: #2563eb;
            background: white;
        }

        .html-preview iframe {
            width: 100%;
            height: 650px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            background: white;
        }

        .pdf-preview {
            max-height: 700px;
            overflow-y: auto;
            padding: 10px;
            background: #f8fafc;
            border-radius: 8px;
        }

        .pdf-page {
            margin-bottom: 25px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            background: white;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
        }

        .alert {
            position: fixed;
            top: 25px;
            right: 25px;
            padding: 18px 24px;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            z-index: 1000;
            animation: slideIn 0.3s;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            min-width: 300px;
        }

        .alert i {
            font-size: 20px;
        }

        .alert.success {
            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
        }

        .alert.error {
            background: linear-gradient(135deg, #ef4444 0%, #f87171 100%);
        }

        .alert.info {
            background: linear-gradient(135deg, #3b82f6 0%, #60a5fa 100%);
        }

        .alert.warning {
            background: linear-gradient(135deg, #f59e0b 0%, #fbbf24 100%);
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .hidden {
            display: none;
        }

        .stats {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            border: 1px solid #e2e8f0;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e2e8f0;
        }

        .stat-row:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .stat-value {
            font-weight: 700;
            color: #2563eb;
        }

        .undo-redo-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .undo-redo-controls button {
            flex: 1;
        }

        .history-info {
            font-size: 13px;
            color: #6b7280;
            text-align: center;
            margin-top: 8px;
        }

        .pdf-edit-options {
            background: #fef3c7;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #fbbf24;
        }

        .pdf-edit-options h4 {
            color: #92400e;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pdf-annotation {
            position: absolute;
            background: rgba(37, 99, 235, 0.1);
            border: 2px solid #2563eb;
            border-radius: 4px;
            cursor: move;
            padding: 5px;
            z-index: 10;
        }

        .pdf-annotation.selected {
            background: rgba(37, 99, 235, 0.2);
            border-color: #1d4ed8;
        }

        .page-number {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 5;
        }

        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .toolbar button {
            padding: 10px 15px;
            font-size: 14px;
        }

        .progress-bar {
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress {
            height: 100%;
            background: #10b981;
            width: 0%;
            transition: width 0.3s ease;
        }

        @media (max-width: 1200px) {
            .editor-grid {
                grid-template-columns: 1fr;
            }
            
            .controls {
                position: static;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .upload-box {
                padding: 30px 20px;
            }
            
            .button-group {
                grid-template-columns: 1fr;
            }
            
            .alert {
                min-width: auto;
                left: 15px;
                right: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-edit"></i> ProEdit - Advanced Universal Editor</h1>
            <p>Upload HTML or PDF ‚Ä¢ Advanced Editing ‚Ä¢ Undo/Redo ‚Ä¢ Real-time Preview</p>
        </div>

        <div class="upload-box" id="uploadBox">
            <i class="fas fa-cloud-upload-alt"></i>
            <h2>üìÅ Click or Drag & Drop to Upload</h2>
            <p>Supports HTML, HTM, and PDF files</p>
            <div class="progress-bar">
                <div class="progress" id="uploadProgress"></div>
            </div>
            <input type="file" id="fileInput" accept=".html,.htm,.pdf">
        </div>

        <div id="editorGrid" class="editor-grid hidden">
            <div class="controls">
                <div id="fileInfo" class="stats">
                    <div class="stat-row">
                        <span><i class="fas fa-file"></i> File:</span>
                        <span class="stat-value" id="fileName">-</span>
                    </div>
                    <div class="stat-row">
                        <span><i class="fas fa-code"></i> Type:</span>
                        <span class="stat-value" id="fileType">-</span>
                    </div>
                    <div class="stat-row">
                        <span><i class="fas fa-weight-hanging"></i> Size:</span>
                        <span class="stat-value" id="fileSize">-</span>
                    </div>
                    <div class="stat-row">
                        <span><i class="fas fa-history"></i> History:</span>
                        <span class="stat-value" id="historyCount">0/0</span>
                    </div>
                </div>

                <div class="undo-redo-controls">
                    <button class="secondary" id="undoBtn" title="Undo (Ctrl+Z)">
                        <i class="fas fa-undo"></i> Undo
                    </button>
                    <button class="secondary" id="redoBtn" title="Redo (Ctrl+Y)">
                        <i class="fas fa-redo"></i> Redo
                    </button>
                </div>
                <div class="history-info" id="historyInfo">No actions performed yet</div>

                <div class="control-group">
                    <label><i class="fas fa-search"></i> üîç Find Text</label>
                    <input type="text" id="findInput" placeholder="Search for text...">
                </div>

                <div class="control-group">
                    <label><i class="fas fa-exchange-alt"></i> ‚úèÔ∏è Replace With</label>
                    <input type="text" id="replaceInput" placeholder="Replace with...">
                    <select id="replaceScope" style="margin-top: 10px;">
                        <option value="all">Replace All</option>
                        <option value="selection">Replace in Selection</option>
                        <option value="case">Case Sensitive</option>
                    </select>
                </div>

                <div class="button-group">
                    <button id="findBtn">
                        <i class="fas fa-search"></i> Find
                    </button>
                    <button id="replaceBtn">
                        <i class="fas fa-sync-alt"></i> Replace
                    </button>
                </div>
                
                <button class="danger" id="clearBtn">
                    <i class="fas fa-broom"></i> Clear Fields
                </button>

                <div id="pdfEditOptions" class="pdf-edit-options hidden">
                    <h4><i class="fas fa-edit"></i> PDF Editing Options</h4>
                    <div class="button-group">
                        <button class="warning" id="addTextBtn">
                            <i class="fas fa-font"></i> Add Text
                        </button>
                        <button class="warning" id="addImageBtn">
                            <i class="fas fa-image"></i> Add Image
                        </button>
                    </div>
                    <button class="success" id="savePdfBtn">
                        <i class="fas fa-save"></i> Save PDF Edits
                    </button>
                </div>

                <div class="stats">
                    <div class="stat-row">
                        <span><i class="fas fa-exchange-alt"></i> Replacements:</span>
                        <span class="stat-value" id="replaceCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span><i class="fas fa-clock"></i> Last Action:</span>
                        <span class="stat-value" id="lastAction">-</span>
                    </div>
                </div>

                <button class="success" id="downloadBtn">
                    <i class="fas fa-download"></i> Download Edited File
                </button>
                <button class="secondary" id="copyBtn" style="display:none;">
                    <i class="fas fa-copy"></i> Copy HTML
                </button>
                <button class="danger" id="resetBtn">
                    <i class="fas fa-trash-alt"></i> Reset Editor
                </button>
            </div>

            <div class="content">
                <div class="toolbar" id="editorToolbar">
                    <!-- Toolbar buttons will be added dynamically -->
                </div>
                <div class="tabs" id="tabs"></div>
                <div id="contentArea"></div>
            </div>
        </div>
    </div>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let state = {
            fileType: null,
            fileName: null,
            originalContent: '',
            currentContent: '',
            pdfData: null,
            pdfDoc: null,
            pdfLibDoc: null,
            replaceCount: 0,
            history: [],
            historyIndex: -1,
            lastAction: null,
            isPdfModified: false,
            pdfPages: [],
            pdfAnnotations: [],
            selection: null
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            setupKeyboardShortcuts();
        });

        function setupEventListeners() {
            // Upload handling
            document.getElementById('uploadBox').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });

            // Drag and drop
            const uploadBox = document.getElementById('uploadBox');
            uploadBox.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadBox.style.borderColor = '#10b981';
                uploadBox.style.transform = 'scale(1.02)';
            });

            uploadBox.addEventListener('dragleave', () => {
                uploadBox.style.borderColor = '#2563eb';
                uploadBox.style.transform = 'scale(1)';
            });

            uploadBox.addEventListener('drop', async (e) => {
                e.preventDefault();
                uploadBox.style.borderColor = '#2563eb';
                uploadBox.style.transform = 'scale(1)';
                
                const file = e.dataTransfer.files[0];
                if (file) {
                    await handleFileUpload(file);
                }
            });

            document.getElementById('fileInput').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    await handleFileUpload(file);
                }
            });

            // Editor controls
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);
            document.getElementById('findBtn').addEventListener('click', findText);
            document.getElementById('replaceBtn').addEventListener('click', replaceText);
            document.getElementById('clearBtn').addEventListener('click', clearFields);
            document.getElementById('downloadBtn').addEventListener('click', downloadFile);
            document.getElementById('copyBtn').addEventListener('click', copyToClipboard);
            document.getElementById('resetBtn').addEventListener('click', resetEditor);
            document.getElementById('savePdfBtn').addEventListener('click', savePdfEdits);
            document.getElementById('addTextBtn').addEventListener('click', addTextToPdf);
            document.getElementById('addImageBtn').addEventListener('click', addImageToPdf);

            // Real-time find
            document.getElementById('findInput').addEventListener('input', debounce(findText, 300));
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && !e.altKey) {
                    switch(e.key.toLowerCase()) {
                        case 'z':
                            if (e.shiftKey) redo();
                            else undo();
                            e.preventDefault();
                            break;
                        case 'y':
                            redo();
                            e.preventDefault();
                            break;
                        case 'f':
                            document.getElementById('findInput').focus();
                            e.preventDefault();
                            break;
                        case 's':
                            if (state.fileType === 'pdf') savePdfEdits();
                            else downloadFile();
                            e.preventDefault();
                            break;
                    }
                }
            });
        }

        async function handleFileUpload(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            showProgress(30);
            
            try {
                if (ext === 'html' || ext === 'htm') {
                    await handleHTML(file);
                } else if (ext === 'pdf') {
                    await handlePDF(file);
                } else {
                    showAlert('Please upload HTML or PDF file', 'error');
                    return;
                }
                showProgress(100);
                setTimeout(() => {
                    document.getElementById('uploadProgress').style.width = '0%';
                }, 500);
            } catch (error) {
                showAlert(`Error loading file: ${error.message}`, 'error');
                showProgress(0);
            }
        }

        function showProgress(percent) {
            document.getElementById('uploadProgress').style.width = percent + '%';
        }

        async function handleHTML(file) {
            state.fileType = 'html';
            state.fileName = file.name;
            state.originalContent = await file.text();
            state.currentContent = state.originalContent;
            
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileType').textContent = 'HTML';
            document.getElementById('fileSize').textContent = formatSize(file.size);
            document.getElementById('copyBtn').style.display = 'block';
            document.getElementById('pdfEditOptions').classList.add('hidden');
            
            resetHistory();
            addToHistory('File loaded');
            setupHTMLTabs();
            showEditor();
            showAlert('HTML loaded successfully!', 'success');
        }

        async function handlePDF(file) {
            state.fileType = 'pdf';
            state.fileName = file.name;
            
            const arrayBuffer = await file.arrayBuffer();
            state.pdfData = new Uint8Array(arrayBuffer);
            
            // Load with pdf.js for display
            const loadingTask = pdfjsLib.getDocument({data: state.pdfData});
            state.pdfDoc = await loadingTask.promise;
            
            // Load with pdf-lib for editing
            state.pdfLibDoc = await PDFLib.PDFDocument.load(state.pdfData);
            state.pdfPages = await state.pdfLibDoc.getPages();
            
            // Extract text
            let text = '';
            for (let i = 1; i <= state.pdfDoc.numPages; i++) {
                const page = await state.pdfDoc.getPage(i);
                const content = await page.getTextContent();
                text += content.items.map(item => item.str).join(' ') + '\n\n';
            }
            
            state.originalContent = text;
            state.currentContent = text;
            
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileType').textContent = 'PDF';
            document.getElementById('fileSize').textContent = formatSize(file.size);
            document.getElementById('copyBtn').style.display = 'none';
            document.getElementById('pdfEditOptions').classList.remove('hidden');
            
            resetHistory();
            addToHistory('PDF loaded');
            setupPDFTabs();
            showEditor();
            showAlert(`PDF loaded! ${state.pdfDoc.numPages} pages ready for editing`, 'success');
        }

        function setupHTMLTabs() {
            const tabs = document.getElementById('tabs');
            tabs.innerHTML = `
                <button class="tab active" data-tab="edit">
                    <i class="fas fa-code"></i> Edit Code
                </button>
                <button class="tab" data-tab="preview">
                    <i class="fas fa-eye"></i> Preview
                </button>
                <button class="tab" data-tab="source">
                    <i class="fas fa-file-code"></i> Source View
                </button>
            `;
            
            setupToolbar('html');
            
            tabs.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    switch(tab.dataset.tab) {
                        case 'edit':
                            showHTMLEditor();
                            break;
                        case 'preview':
                            showHTMLPreview();
                            break;
                        case 'source':
                            showHTMLSource();
                            break;
                    }
                });
            });
            
            showHTMLEditor();
        }

        function setupPDFTabs() {
            const tabs = document.getElementById('tabs');
            tabs.innerHTML = `
                <button class="tab active" data-tab="edit">
                    <i class="fas fa-edit"></i> Edit Text
                </button>
                <button class="tab" data-tab="preview">
                    <i class="fas fa-file-pdf"></i> View PDF
                </button>
                <button class="tab" data-tab="annotate">
                    <i class="fas fa-draw-polygon"></i> Annotate
                </button>
            `;
            
            setupToolbar('pdf');
            
            tabs.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    switch(tab.dataset.tab) {
                        case 'edit':
                            showPDFEditor();
                            break;
                        case 'preview':
                            showPDFPreview();
                            break;
                        case 'annotate':
                            showPDFAnnotation();
                            break;
                    }
                });
            });
            
            showPDFEditor();
        }

        function setupToolbar(type) {
            const toolbar = document.getElementById('editorToolbar');
            
            if (type === 'html') {
                toolbar.innerHTML = `
                    <button onclick="formatText('bold')" title="Bold (Ctrl+B)"><i class="fas fa-bold"></i></button>
                    <button onclick="formatText('italic')" title="Italic (Ctrl+I)"><i class="fas fa-italic"></i></button>
                    <button onclick="formatText('underline')" title="Underline (Ctrl+U)"><i class="fas fa-underline"></i></button>
                    <div style="width:1px; background:#e5e7eb; margin:0 10px;"></div>
                    <button onclick="insertTag('<h1>', '</h1>')"><i class="fas fa-heading"></i> H1</button>
                    <button onclick="insertTag('<p>', '</p>')"><i class="fas fa-paragraph"></i> P</button>
                    <button onclick="insertTag('<a href=\"\">', '</a>')"><i class="fas fa-link"></i> Link</button>
                    <button onclick="insertTag('<img src=\"\" alt=\"\">', '')"><i class="fas fa-image"></i> Image</button>
                `;
            } else {
                toolbar.innerHTML = `
                    <button onclick="highlightText()" title="Highlight selected text"><i class="fas fa-highlighter"></i></button>
                    <button onclick="addComment()" title="Add comment"><i class="fas fa-comment"></i></button>
                    <button onclick="drawRectangle()" title="Draw rectangle"><i class="fas fa-square"></i></button>
                    <button onclick="drawCircle()" title="Draw circle"><i class="fas fa-circle"></i></button>
                    <button onclick="addStamp()" title="Add stamp"><i class="fas fa-stamp"></i></button>
                `;
            }
        }

        function showHTMLEditor() {
            const content = document.getElementById('contentArea');
            content.innerHTML = '<textarea class="text-editor" id="editor"></textarea>';
            const editor = document.getElementById('editor');
            editor.value = state.currentContent;
            
            editor.addEventListener('input', (e) => {
                const oldContent = state.currentContent;
                state.currentContent = e.target.value;
                if (oldContent !== state.currentContent) {
                    addToHistory('Text edited');
                }
            });
            
            editor.addEventListener('select', () => {
                state.selection = {
                    start: editor.selectionStart,
                    end: editor.selectionEnd,
                    text: editor.value.substring(editor.selectionStart, editor.selectionEnd)
                };
            });
            
            editor.focus();
        }

        function showHTMLPreview() {
            const content = document.getElementById('contentArea');
            content.innerHTML = '<div class="html-preview"><iframe id="previewFrame"></iframe></div>';
            const iframe = document.getElementById('previewFrame');
            iframe.srcdoc = state.currentContent;
        }

        function showHTMLSource() {
            const content = document.getElementById('contentArea');
            content.innerHTML = `
                <div style="display: flex; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin-bottom: 10px;">Original</h3>
                        <textarea class="text-editor" style="min-height: 600px; background: #fef2f2;" readonly>${state.originalContent}</textarea>
                    </div>
                    <div style="flex: 1;">
                        <h3 style="margin-bottom: 10px;">Edited</h3>
                        <textarea class="text-editor" style="min-height: 600px; background: #f0fdf4;">${state.currentContent}</textarea>
                    </div>
                </div>
            `;
        }

        function showPDFEditor() {
            const content = document.getElementById('contentArea');
            content.innerHTML = '<textarea class="text-editor" id="editor" placeholder="Edit extracted PDF text here..."></textarea>';
            const editor = document.getElementById('editor');
            editor.value = state.currentContent;
            
            editor.addEventListener('input', (e) => {
                const oldContent = state.currentContent;
                state.currentContent = e.target.value;
                if (oldContent !== state.currentContent) {
                    addToHistory('PDF text edited');
                    state.isPdfModified = true;
                }
            });
        }

        async function showPDFPreview() {
            const content = document.getElementById('contentArea');
            content.innerHTML = '<div class="pdf-preview" id="pdfPreview"></div>';
            const container = document.getElementById('pdfPreview');
            container.innerHTML = '';
            
            for (let i = 1; i <= state.pdfDoc.numPages; i++) {
                const page = await state.pdfDoc.getPage(i);
                const viewport = page.getViewport({scale: 1.2});
                
                const pageDiv = document.createElement('div');
                pageDiv.className = 'pdf-page';
                pageDiv.dataset.page = i;
                
                const pageNumber = document.createElement('div');
                pageNumber.className = 'page-number';
                pageNumber.textContent = `Page ${i}`;
                pageDiv.appendChild(pageNumber);
                
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = viewport.height;
                canvas.width = viewport.width;
                
                await page.render({
                    canvasContext: context,
                    viewport: viewport
                }).promise;
                
                pageDiv.appendChild(canvas);
                container.appendChild(pageDiv);
            }
        }

        function showPDFAnnotation() {
            showPDFPreview().then(() => {
                const pages = document.querySelectorAll('.pdf-page');
                pages.forEach(page => {
                    page.style.position = 'relative';
                    page.addEventListener('click', (e) => {
                        const rect = page.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        
                        addAnnotation(page, x, y);
                    });
                });
            });
        }

        function addAnnotation(pageElement, x, y) {
            const annotation = document.createElement('div');
            annotation.className = 'pdf-annotation';
            annotation.style.left = x + 'px';
            annotation.style.top = y + 'px';
            annotation.style.width = '200px';
            annotation.style.height = '100px';
            
            const textarea = document.createElement('textarea');
            textarea.style.width = '100%';
            textarea.style.height = '100%';
            textarea.style.border = 'none';
            textarea.style.background = 'transparent';
            textarea.style.resize = 'none';
            textarea.placeholder = 'Type annotation here...';
            
            annotation.appendChild(textarea);
            pageElement.appendChild(annotation);
            
            // Make draggable
            makeDraggable(annotation);
            
            state.pdfAnnotations.push({
                element: annotation,
                page: parseInt(pageElement.dataset.page),
                x,
                y
            });
            
            addToHistory('Annotation added');
        }

        function makeDraggable(element) {
            let isDragging = false;
            let offsetX, offsetY;
            
            element.addEventListener('mousedown', (e) => {
                isDragging = true;
                offsetX = e.clientX - element.getBoundingClientRect().left;
                offsetY = e.clientY - element.getBoundingClientRect().top;
                element.classList.add('selected');
                
                document.addEventListener('mousemove', mouseMove);
                document.addEventListener('mouseup', mouseUp);
                
                e.preventDefault();
            });
            
            function mouseMove(e) {
                if (isDragging) {
                    const parentRect = element.parentElement.getBoundingClientRect();
                    const x = e.clientX - parentRect.left - offsetX;
                    const y = e.clientY - parentRect.top - offsetY;
                    
                    element.style.left = Math.max(0, Math.min(parentRect.width - element.offsetWidth, x)) + 'px';
                    element.style.top = Math.max(0, Math.min(parentRect.height - element.offsetHeight, y)) + 'px';
                }
            }
            
            function mouseUp() {
                isDragging = false;
                element.classList.remove('selected');
                document.removeEventListener('mousemove', mouseMove);
                document.removeEventListener('mouseup', mouseUp);
                
                // Update annotation position
                const annotation = state.pdfAnnotations.find(a => a.element === element);
                if (annotation) {
                    annotation.x = parseInt(element.style.left);
                    annotation.y = parseInt(element.style.top);
                    addToHistory('Annotation moved');
                }
            }
        }

        function showEditor() {
            document.getElementById('editorGrid').classList.remove('hidden');
        }

        // History management
        function resetHistory() {
            state.history = [];
            state.historyIndex = -1;
            updateHistoryUI();
        }

        function addToHistory(action) {
            // Remove future history if we're not at the end
            if (state.historyIndex < state.history.length - 1) {
                state.history = state.history.slice(0, state.historyIndex + 1);
            }
            
            state.history.push({
                content: state.currentContent,
                action: action,
                timestamp: new Date().toLocaleTimeString(),
                pdfData: state.fileType === 'pdf' ? state.pdfLibDoc ? state.pdfLibDoc.save() : null : null
            });
            
            state.historyIndex = state.history.length - 1;
            state.lastAction = action;
            
            updateHistoryUI();
            document.getElementById('lastAction').textContent = action;
        }

        function undo() {
            if (state.historyIndex > 0) {
                state.historyIndex--;
                const historyItem = state.history[state.historyIndex];
                state.currentContent = historyItem.content;
                
                // Update editor if visible
                const editor = document.getElementById('editor');
                if (editor) {
                    editor.value = state.currentContent;
                }
                
                updateHistoryUI();
                state.lastAction = `Undo: ${historyItem.action}`;
                document.getElementById('lastAction').textContent = state.lastAction;
                
                showAlert(`Undo: ${historyItem.action}`, 'info');
            }
        }

        function redo() {
            if (state.historyIndex < state.history.length - 1) {
                state.historyIndex++;
                const historyItem = state.history[state.historyIndex];
                state.currentContent = historyItem.content;
                
                // Update editor if visible
                const editor = document.getElementById('editor');
                if (editor) {
                    editor.value = state.currentContent;
                }
                
                updateHistoryUI();
                state.lastAction = `Redo: ${historyItem.action}`;
                document.getElementById('lastAction').textContent = state.lastAction;
                
                showAlert(`Redo: ${historyItem.action}`, 'info');
            }
        }

        function updateHistoryUI() {
            document.getElementById('historyCount').textContent = 
                `${state.historyIndex + 1}/${state.history.length}`;
            
            document.getElementById('undoBtn').disabled = state.historyIndex <= 0;
            document.getElementById('redoBtn').disabled = state.historyIndex >= state.history.length - 1;
            
            const historyInfo = document.getElementById('historyInfo');
            if (state.history.length > 0) {
                const current = state.history[state.historyIndex];
                historyInfo.textContent = `${current.action} at ${current.timestamp}`;
            } else {
                historyInfo.textContent = 'No actions performed yet';
            }
        }

        // Text editing functions
        function findText() {
            const find = document.getElementById('findInput').value;
            if (!find) return;
            
            const editor = document.getElementById('editor');
            if (!editor) return;
            
            const text = editor.value;
            const regex = new RegExp(find.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            const matches = text.match(regex);
            
            if (matches) {
                // Highlight matches
                editor.focus();
                const firstIndex = text.toLowerCase().indexOf(find.toLowerCase());
                if (firstIndex !== -1) {
                    editor.setSelectionRange(firstIndex, firstIndex + find.length);
                }
                showAlert(`Found ${matches.length} match(es)`, 'info');
            } else {
                showAlert('No matches found', 'warning');
            }
        }

        function replaceText() {
            const find = document.getElementById('findInput').value;
            const replace = document.getElementById('replaceInput').value;
            const scope = document.getElementById('replaceScope').value;
            
            if (!find) {
                showAlert('Enter text to find', 'error');
                return;
            }
            
            const editor = document.getElementById('editor');
            if (!editor) return;
            
            let text = editor.value;
            let regex;
            
            if (scope === 'case') {
                regex = new RegExp(find.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
            } else {
                regex = new RegExp(find.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            }
            
            let newText;
            let count = 0;
            
            if (scope === 'selection' && state.selection) {
                const selectedText = state.selection.text;
                newText = selectedText.replace(regex, replace);
                count = (selectedText.match(regex) || []).length;
                
                text = text.substring(0, state.selection.start) + 
                       newText + 
                       text.substring(state.selection.end);
            } else {
                const matches = text.match(regex);
                count = matches ? matches.length : 0;
                newText = text.replace(regex, replace);
            }
            
            if (count === 0) {
                showAlert('No matches found', 'info');
                return;
            }
            
            const oldContent = state.currentContent;
            state.currentContent = newText;
            editor.value = newText;
            
            state.replaceCount += count;
            document.getElementById('replaceCount').textContent = state.replaceCount;
            
            addToHistory(`Replaced ${count} occurrence(s)`);
            showAlert(`Replaced ${count} occurrence(s)!`, 'success');
        }

        function clearFields() {
            document.getElementById('findInput').value = '';
            document.getElementById('replaceInput').value = '';
            showAlert('Fields cleared', 'info');
        }

        // PDF editing functions
        async function addTextToPdf() {
            if (!state.pdfLibDoc) {
                showAlert('PDF not loaded properly', 'error');
                return;
            }
            
            const text = prompt('Enter text to add to PDF:', 'Sample Text');
            if (!text) return;
            
            try {
                const pageIndex = 0; // Add to first page
                const page = state.pdfPages[pageIndex];
                const { width, height } = page.getSize();
                
                page.drawText(text, {
                    x: 50,
                    y: height - 100,
                    size: 20,
                    color: PDFLib.rgb(0, 0, 0),
                });
                
                state.isPdfModified = true;
                addToHistory('Text added to PDF');
                showAlert('Text added to PDF (will be saved when you download)', 'success');
            } catch (error) {
                showAlert(`Error adding text: ${error.message}`, 'error');
            }
        }

        async function addImageToPdf() {
            showAlert('Image upload coming soon!', 'info');
            // Implement image upload and embedding
        }

        async function savePdfEdits() {
            if (!state.isPdfModified && state.pdfAnnotations.length === 0) {
                showAlert('No changes to save', 'info');
                return;
            }
            
            try {
                // Save annotations as overlay (for demo)
                // In a real app, you'd embed these into the PDF
                
                const pdfBytes = await state.pdfLibDoc.save();
                const blob = new Blob([pdfBytes], {type: 'application/pdf'});
                download(blob, state.fileName.replace('.pdf', '_edited.pdf'));
                
                addToHistory('PDF saved with edits');
                state.isPdfModified = false;
                showAlert('PDF saved successfully!', 'success');
            } catch (error) {
                showAlert(`Error saving PDF: ${error.message}`, 'error');
            }
        }

        // Utility functions
        function downloadFile() {
            if (state.fileType === 'html') {
                const blob = new Blob([state.currentContent], {type: 'text/html'});
                download(blob, state.fileName.replace(/\.(html|htm)$/, '_edited.html'));
                showAlert('HTML downloaded!', 'success');
            } else if (state.fileType === 'pdf') {
                if (state.isPdfModified || state.pdfAnnotations.length > 0) {
                    // Offer to save PDF edits
                    if (confirm('You have unsaved PDF edits. Save them before downloading?')) {
                        savePdfEdits();
                    } else {
                        // Download extracted text
                        const blob = new Blob([state.currentContent], {type: 'text/plain'});
                        download(blob, state.fileName.replace('.pdf', '_extracted.txt'));
                        showAlert('Text file downloaded!', 'info');
                    }
                } else {
                    // Download extracted text
                    const blob = new Blob([state.currentContent], {type: 'text/plain'});
                    download(blob, state.fileName.replace('.pdf', '_extracted.txt'));
                    showAlert('Text file downloaded!', 'info');
                }
            }
        }

        async function copyToClipboard() {
            try {
                await navigator.clipboard.writeText(state.currentContent);
                showAlert('HTML copied to clipboard!', 'success');
            } catch (e) {
                showAlert('Failed to copy', 'error');
            }
        }

        function resetEditor() {
            if (confirm('Are you sure you want to reset the editor? All unsaved changes will be lost.')) {
                state.currentContent = state.originalContent;
                state.replaceCount = 0;
                state.isPdfModified = false;
                state.pdfAnnotations = [];
                
                const editor = document.getElementById('editor');
                if (editor) {
                    editor.value = state.currentContent;
                }
                
                document.getElementById('replaceCount').textContent = '0';
                document.getElementById('lastAction').textContent = '-';
                
                resetHistory();
                showAlert('Editor reset to original state', 'info');
            }
        }

        function download(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function showAlert(message, type) {
            const alert = document.createElement('div');
            alert.className = `alert ${type}`;
            
            const icons = {
                success: 'fa-check-circle',
                error: 'fa-exclamation-circle',
                info: 'fa-info-circle',
                warning: 'fa-exclamation-triangle'
            };
            
            alert.innerHTML = `
                <i class="fas ${icons[type]}"></i>
                <span>${message}</span>
            `;
            
            document.body.appendChild(alert);
            setTimeout(() => {
                alert.style.animation = 'slideIn 0.3s reverse';
                setTimeout(() => alert.remove(), 300);
            }, 3000);
        }

        // HTML formatting functions
        function formatText(format) {
            const editor = document.getElementById('editor');
            if (!editor) return;
            
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            const selectedText = editor.value.substring(start, end);
            
            let formattedText;
            switch(format) {
                case 'bold':
                    formattedText = `<strong>${selectedText}</strong>`;
                    break;
                case 'italic':
                    formattedText = `<em>${selectedText}</em>`;
                    break;
                case 'underline':
                    formattedText = `<u>${selectedText}</u>`;
                    break;
                default:
                    return;
            }
            
            const newText = editor.value.substring(0, start) + 
                           formattedText + 
                           editor.value.substring(end);
            
            state.currentContent = newText;
            editor.value = newText;
            addToHistory(`Formatted text as ${format}`);
        }

        function insertTag(startTag, endTag) {
            const editor = document.getElementById('editor');
            if (!editor) return;
            
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            const selectedText = editor.value.substring(start, end);
            
            const newText = editor.value.substring(0, start) + 
                           startTag + selectedText + endTag + 
                           editor.value.substring(end);
            
            state.currentContent = newText;
            editor.value = newText;
            addToHistory(`Inserted ${startTag} tag`);
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // PDF annotation functions
        function highlightText() {
            showAlert('Click on PDF to highlight text', 'info');
        }

        function addComment() {
            showAlert('Click on PDF to add comment', 'info');
        }

        function drawRectangle() {
            showAlert('Click and drag on PDF to draw rectangle', 'info');
        }

        function drawCircle() {
            showAlert('Click and drag on PDF to draw circle', 'info');
        }

        function addStamp() {
            const stamps = ['APPROVED', 'CONFIDENTIAL', 'DRAFT', 'URGENT'];
            const stamp = stamps[Math.floor(Math.random() * stamps.length)];
            showAlert(`Added ${stamp} stamp`, 'info');
            addToHistory(`Added ${stamp} stamp`);
        }
    </script>
</body>
</html>
