<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ProEdit - Advanced Universal Editor</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4edf5 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: white;
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.08);
            border-left: 5px solid #2563eb;
        }

        .header h1 {
            color: #2563eb;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 28px;
        }

        .upload-box {
            border: 3px dashed #2563eb;
            padding: 50px;
            text-align: center;
            background: linear-gradient(135deg, #eff6ff 0%, #e0f2fe 100%);
            border-radius: 12px;
            cursor: pointer;
            margin-bottom: 25px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .upload-box:hover {
            background: linear-gradient(135deg, #dbeafe 0%, #bae6fd 100%);
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(37, 99, 235, 0.15);
        }

        .upload-box i {
            font-size: 48px;
            color: #2563eb;
            margin-bottom: 15px;
        }

        input[type="file"] {
            display: none;
        }

        .editor-grid {
            display: grid;
            grid-template-columns: 450px 1fr;
            gap: 25px;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .controls {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.08);
            height: fit-content;
            position: sticky;
            top: 25px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 10px;
            color: #1f2937;
            font-size: 15px;
        }

        .control-group input[type="text"],
        .control-group textarea,
        .control-group select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            transition: border 0.3s ease;
        }

        .control-group input:focus,
        .control-group textarea:focus,
        .control-group select:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .control-group textarea {
            min-height: 120px;
            resize: vertical;
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        button {
            padding: 14px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            font-size: 15px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:hover {
            background: #1d4ed8;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: #6b7280;
        }

        button.secondary:hover {
            background: #4b5563;
        }

        button.success {
            background: #10b981;
        }

        button.success:hover {
            background: #059669;
        }

        button.danger {
            background: #ef4444;
        }

        button.danger:hover {
            background: #dc2626;
        }

        button.warning {
            background: #f59e0b;
        }

        button.warning:hover {
            background: #d97706;
        }

        button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
        }

        .content {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.08);
            min-height: 700px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 10px;
        }

        .tab {
            padding: 12px 24px;
            background: #f3f4f6;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .tab.active {
            background: #2563eb;
            color: white;
        }

        .tab:hover:not(.active) {
            background: #e5e7eb;
        }

        .text-editor {
            width: 100%;
            min-height: 650px;
            padding: 25px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            background: #fafafa;
        }

        .text-editor:focus {
            outline: none;
            border-color: #2563eb;
            background: white;
        }

        .html-preview iframe {
            width: 100%;
            height: 650px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            background: white;
        }

        .pdf-preview {
            max-height: 700px;
            overflow-y: auto;
            padding: 10px;
            background: #f8fafc;
            border-radius: 8px;
        }

        .pdf-page {
            margin-bottom: 25px;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            background: white;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
        }

        .alert {
            position: fixed;
            top: 25px;
            right: 25px;
            padding: 18px 24px;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            z-index: 1000;
            animation: slideIn 0.3s;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.1);
            min-width: 300px;
        }

        .alert i {
            font-size: 20px;
        }

        .alert.success {
            background: linear-gradient(135deg, #10b981 0%, #34d399 100%);
        }

        .alert.error {
            background: linear-gradient(135deg, #ef4444 0%, #f87171 100%);
        }

        .alert.info {
            background: linear-gradient(135deg, #3b82f6 0%, #60a5fa 100%);
        }

        .alert.warning {
            background: linear-gradient(135deg, #f59e0b 0%, #fbbf24 100%);
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .hidden {
            display: none;
        }

        .stats {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            border: 1px solid #e2e8f0;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e2e8f0;
        }

        .stat-row:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .stat-value {
            font-weight: 700;
            color: #2563eb;
        }

        .undo-redo-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .undo-redo-controls button {
            flex: 1;
        }

        .history-info {
            font-size: 13px;
            color: #6b7280;
            text-align: center;
            margin-top: 8px;
        }

        .pdf-edit-options {
            background: #fef3c7;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #fbbf24;
        }

        .pdf-edit-options h4 {
            color: #92400e;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pdf-annotation {
            position: absolute;
            background: rgba(37, 99, 235, 0.1);
            border: 2px solid #2563eb;
            border-radius: 4px;
            cursor: move;
            padding: 5px;
            z-index: 10;
        }

        .pdf-annotation.selected {
            background: rgba(37, 99, 235, 0.2);
            border-color: #1d4ed8;
        }

        .page-number {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 5;
        }

        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            flex-wrap: wrap;
        }

        .toolbar button {
            padding: 10px 15px;
            font-size: 14px;
        }

        .progress-bar {
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress {
            height: 100%;
            background: #10b981;
            width: 0%;
            transition: width 0.3s ease;
        }

        .pdf-upload-options {
            margin-top: 20px;
            padding: 15px;
            background: #f0f9ff;
            border-radius: 8px;
            border: 1px solid #7dd3fc;
        }

        .pdf-upload-options h4 {
            color: #0369a1;
            margin-bottom: 10px;
        }

        .radio-group {
            display: flex;
            gap: 15px;
            margin: 10px 0;
        }

        .radio-group label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
        }

        /* Bulk Find & Replace Styles */
        .bulk-replace-section {
            background: linear-gradient(135deg, #f0fdf4 0%, #dcfce7 100%);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
            border: 2px solid #10b981;
        }

        .bulk-replace-section h3 {
            color: #065f46;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 16px;
        }

        .replace-row {
            display: grid;
            grid-template-columns: 1fr 1fr 40px;
            gap: 10px;
            margin-bottom: 12px;
            align-items: center;
            background: white;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #d1fae5;
            transition: all 0.2s ease;
        }

        .replace-row:hover {
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.1);
        }

        .replace-row input {
            padding: 10px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            font-size: 13px;
            font-family: 'Inter', sans-serif;
        }

        .replace-row input:focus {
            outline: none;
            border-color: #10b981;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
        }

        .replace-row input::placeholder {
            color: #9ca3af;
        }

        .remove-row-btn {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 6px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            padding: 0;
        }

        .remove-row-btn:hover {
            background: #dc2626;
            transform: scale(1.05);
        }

        .remove-row-btn i {
            font-size: 16px;
        }

        .bulk-replace-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .add-row-btn {
            background: #10b981;
            grid-column: span 2;
        }

        .add-row-btn:hover {
            background: #059669;
        }

        .replace-options {
            margin-top: 15px;
            padding: 12px;
            background: white;
            border-radius: 8px;
            border: 1px solid #d1fae5;
        }

        .replace-options label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            font-size: 14px;
            color: #374151;
        }

        .replace-options input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .bulk-results {
            margin-top: 15px;
            padding: 12px;
            background: white;
            border-radius: 8px;
            border: 1px solid #d1fae5;
            display: none;
        }

        .bulk-results.show {
            display: block;
        }

        .bulk-results h4 {
            color: #065f46;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .result-item {
            padding: 8px;
            margin-bottom: 6px;
            background: #f0fdf4;
            border-radius: 4px;
            font-size: 13px;
            color: #166534;
        }

        @media (max-width: 1200px) {
            .editor-grid {
                grid-template-columns: 1fr;
            }
            
            .controls {
                position: static;
                max-height: none;
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .upload-box {
                padding: 30px 20px;
            }
            
            .button-group {
                grid-template-columns: 1fr;
            }
            
            .alert {
                min-width: auto;
                left: 15px;
                right: 15px;
            }

            .replace-row {
                grid-template-columns: 1fr;
            }

            .remove-row-btn {
                width: 100%;
            }
        }

        .pdf-text-overlay {
            position: absolute;
            border: 2px solid transparent;
            cursor: text;
            user-select: text;
        }

        .pdf-text-overlay:hover {
            border-color: rgba(37, 99, 235, 0.3);
            background: rgba(37, 99, 235, 0.05);
        }

        .pdf-text-overlay.editing {
            border-color: #2563eb;
            background: white;
            z-index: 100;
        }

        .pdf-text-input {
            width: 100%;
            height: 100%;
            border: none;
            background: transparent;
            font-family: inherit;
            font-size: inherit;
            padding: 2px;
        }

        .pdf-text-input:focus {
            outline: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-edit"></i> ProEdit - Advanced Universal Editor</h1>
            <p>Upload HTML or PDF ‚Ä¢ Bulk Find & Replace ‚Ä¢ Advanced Editing ‚Ä¢ Real-time Preview</p>
        </div>

        <div class="upload-box" id="uploadBox">
            <i class="fas fa-cloud-upload-alt"></i>
            <h2>üìÅ Click or Drag & Drop to Upload</h2>
            <p>Supports HTML, HTM, and PDF files</p>
            <div class="progress-bar">
                <div class="progress" id="uploadProgress"></div>
            </div>
            <input type="file" id="fileInput" accept=".html,.htm,.pdf">
        </div>

        <div id="editorGrid" class="editor-grid hidden">
            <div class="controls">
                <div id="fileInfo" class="stats">
                    <div class="stat-row">
                        <span><i class="fas fa-file"></i> File:</span>
                        <span class="stat-value" id="fileName">-</span>
                    </div>
                    <div class="stat-row">
                        <span><i class="fas fa-code"></i> Type:</span>
                        <span class="stat-value" id="fileType">-</span>
                    </div>
                    <div class="stat-row">
                        <span><i class="fas fa-weight-hanging"></i> Size:</span>
                        <span class="stat-value" id="fileSize">-</span>
                    </div>
                    <div class="stat-row">
                        <span><i class="fas fa-history"></i> History:</span>
                        <span class="stat-value" id="historyCount">0/0</span>
                    </div>
                </div>

                <div class="undo-redo-controls">
                    <button class="secondary" id="undoBtn" title="Undo (Ctrl+Z)">
                        <i class="fas fa-undo"></i> Undo
                    </button>
                    <button class="secondary" id="redoBtn" title="Redo (Ctrl+Y)">
                        <i class="fas fa-redo"></i> Redo
                    </button>
                </div>
                <div class="history-info" id="historyInfo">No actions performed yet</div>

                <!-- Bulk Find & Replace Section -->
                <div id="bulkReplaceSection" class="bulk-replace-section hidden">
                    <h3>
                        <i class="fas fa-list-check"></i> Bulk Find & Replace
                    </h3>
                    
                    <div id="replaceRows">
                        <!-- Replace rows will be added here -->
                    </div>

                    <button class="add-row-btn" id="addRowBtn">
                        <i class="fas fa-plus"></i> Add New Row
                    </button>

                    <div class="replace-options">
                        <label>
                            <input type="checkbox" id="caseSensitive">
                            Case Sensitive
                        </label>
                        <label>
                            <input type="checkbox" id="wholeWord">
                            Match Whole Word Only
                        </label>
                        <label>
                            <input type="checkbox" id="useRegex">
                            Use Regular Expression
                        </label>
                    </div>

                    <div class="bulk-replace-controls">
                        <button id="bulkReplaceBtn" class="success">
                            <i class="fas fa-sync-alt"></i> Replace All
                        </button>
                        <button id="clearBulkBtn" class="secondary">
                            <i class="fas fa-eraser"></i> Clear All
                        </button>
                    </div>

                    <div id="bulkResults" class="bulk-results">
                        <h4><i class="fas fa-check-circle"></i> Results:</h4>
                        <div id="resultsContent"></div>
                    </div>
                </div>

                <!-- Single Find & Replace (Legacy) -->
                <div class="control-group">
                    <label><i class="fas fa-search"></i> üîç Find Text</label>
                    <input type="text" id="findInput" placeholder="Search for text...">
                </div>

                <div class="control-group">
                    <label><i class="fas fa-exchange-alt"></i> ‚úèÔ∏è Replace With</label>
                    <input type="text" id="replaceInput" placeholder="Replace with...">
                    <select id="replaceScope" style="margin-top: 10px;">
                        <option value="all">Replace All</option>
                        <option value="selection">Replace in Selection</option>
                        <option value="case">Case Sensitive</option>
                    </select>
                </div>

                <div class="button-group">
                    <button id="findBtn">
                        <i class="fas fa-search"></i> Find
                    </button>
                    <button id="replaceBtn">
                        <i class="fas fa-sync-alt"></i> Replace
                    </button>
                </div>
                
                <button class="danger" id="clearBtn">
                    <i class="fas fa-broom"></i> Clear Fields
                </button>

                <div id="pdfEditOptions" class="pdf-edit-options hidden">
                    <h4><i class="fas fa-edit"></i> PDF Editing Options</h4>
                    <div class="button-group">
                        <button class="warning" id="addTextBtn">
                            <i class="fas fa-font"></i> Add Text
                        </button>
                        <button class="warning" id="addImageBtn">
                            <i class="fas fa-image"></i> Add Image
                        </button>
                    </div>
                    <button class="success" id="savePdfBtn">
                        <i class="fas fa-save"></i> Save PDF Edits
                    </button>
                    <div class="pdf-upload-options">
                        <h4><i class="fas fa-cog"></i> PDF Processing</h4>
                        <p style="font-size: 12px; margin-bottom: 10px;">If PDF fails to load, try:</p>
                        <div class="radio-group">
                            <label>
                                <input type="radio" name="pdfMode" value="text" checked>
                                Text Extraction Only
                            </label>
                            <label>
                                <input type="radio" name="pdfMode" value="full">
                                Full PDF View
                            </label>
                        </div>
                        <button id="reprocessPdfBtn" class="secondary" style="margin-top: 10px; padding: 8px;">
                            <i class="fas fa-redo"></i> Reprocess PDF
                        </button>
                    </div>
                </div>

                <div class="stats">
                    <div class="stat-row">
                        <span><i class="fas fa-exchange-alt"></i> Replacements:</span>
                        <span class="stat-value" id="replaceCount">0</span>
                    </div>
                    <div class="stat-row">
                        <span><i class="fas fa-clock"></i> Last Action:</span>
                        <span class="stat-value" id="lastAction">-</span>
                    </div>
                </div>

                <button class="success" id="downloadBtn">
                    <i class="fas fa-download"></i> Download Edited File
                </button>
                <button class="secondary" id="copyBtn" style="display:none;">
                    <i class="fas fa-copy"></i> Copy HTML
                </button>
                <button class="danger" id="resetBtn">
                    <i class="fas fa-trash-alt"></i> Reset Editor
                </button>
            </div>

            <div class="content">
                <div class="toolbar" id="editorToolbar">
                    <!-- Toolbar buttons will be added dynamically -->
                </div>
                <div class="tabs" id="tabs"></div>
                <div id="contentArea"></div>
            </div>
        </div>
    </div>

    <script>
        // Set PDF.js worker source
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }

        let state = {
            fileType: null,
            fileName: null,
            originalContent: '',
            currentContent: '',
            pdfData: null,
            pdfDoc: null,
            pdfLibDoc: null,
            replaceCount: 0,
            history: [],
            historyIndex: -1,
            lastAction: null,
            isPdfModified: false,
            pdfPages: [],
            pdfAnnotations: [],
            selection: null,
            pdfMode: 'full',
            bulkReplaceRows: [],
            pdfTextLayers: [] // Store text content for editing
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            setupKeyboardShortcuts();
            initializeBulkReplace();
        });

        function setupEventListeners() {
            // Upload handling
            document.getElementById('uploadBox').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });

            // Drag and drop
            const uploadBox = document.getElementById('uploadBox');
            uploadBox.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadBox.style.borderColor = '#10b981';
                uploadBox.style.transform = 'scale(1.02)';
            });

            uploadBox.addEventListener('dragleave', () => {
                uploadBox.style.borderColor = '#2563eb';
                uploadBox.style.transform = 'scale(1)';
            });

            uploadBox.addEventListener('drop', async (e) => {
                e.preventDefault();
                uploadBox.style.borderColor = '#2563eb';
                uploadBox.style.transform = 'scale(1)';
                
                const file = e.dataTransfer.files[0];
                if (file) {
                    await handleFileUpload(file);
                }
            });

            document.getElementById('fileInput').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    await handleFileUpload(file);
                }
            });

            // Editor controls
            document.getElementById('undoBtn').addEventListener('click', undo);
            document.getElementById('redoBtn').addEventListener('click', redo);
            document.getElementById('findBtn').addEventListener('click', findText);
            document.getElementById('replaceBtn').addEventListener('click', replaceText);
            document.getElementById('clearBtn').addEventListener('click', clearFields);
            document.getElementById('downloadBtn').addEventListener('click', downloadFile);
            document.getElementById('copyBtn').addEventListener('click', copyToClipboard);
            document.getElementById('resetBtn').addEventListener('click', resetEditor);
            document.getElementById('savePdfBtn').addEventListener('click', savePdfEdits);
            document.getElementById('addTextBtn').addEventListener('click', addTextToPdf);
            document.getElementById('addImageBtn').addEventListener('click', addImageToPdf);
            document.getElementById('reprocessPdfBtn').addEventListener('click', reprocessPdf);

            // Bulk Replace controls
            document.getElementById('addRowBtn').addEventListener('click', addBulkReplaceRow);
            document.getElementById('bulkReplaceBtn').addEventListener('click', executeBulkReplace);
            document.getElementById('clearBulkBtn').addEventListener('click', clearBulkReplace);

            // PDF mode selection
            document.querySelectorAll('input[name="pdfMode"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    state.pdfMode = e.target.value;
                });
            });

            // Real-time find
            document.getElementById('findInput').addEventListener('input', debounce(findText, 300));
        }

        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && !e.altKey) {
                    switch(e.key.toLowerCase()) {
                        case 'z':
                            if (e.shiftKey) redo();
                            else undo();
                            e.preventDefault();
                            break;
                        case 'y':
                            redo();
                            e.preventDefault();
                            break;
                        case 'f':
                            document.getElementById('findInput').focus();
                            e.preventDefault();
                            break;
                        case 's':
                            if (state.fileType === 'pdf') savePdfEdits();
                            else downloadFile();
                            e.preventDefault();
                            break;
                    }
                }
            });
        }

        // Bulk Replace Functions
        function initializeBulkReplace() {
            // Add 3 default rows
            for (let i = 0; i < 3; i++) {
                addBulkReplaceRow();
            }
        }

        function addBulkReplaceRow() {
            const rowId = Date.now() + Math.random();
            const row = {
                id: rowId,
                find: '',
                replace: ''
            };
            
            state.bulkReplaceRows.push(row);
            renderBulkReplaceRows();
        }

        function renderBulkReplaceRows() {
            const container = document.getElementById('replaceRows');
            container.innerHTML = '';
            
            state.bulkReplaceRows.forEach((row, index) => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'replace-row';
                rowDiv.innerHTML = `
                    <input type="text" 
                           placeholder="Find text..." 
                           data-id="${row.id}" 
                           data-field="find"
                           value="${row.find}">
                    <input type="text" 
                           placeholder="Replace with..." 
                           data-id="${row.id}" 
                           data-field="replace"
                           value="${row.replace}">
                    <button class="remove-row-btn" data-id="${row.id}" title="Remove row">
                        <i class="fas fa-times"></i>
                    </button>
                `;
                
                // Add event listeners
                const inputs = rowDiv.querySelectorAll('input');
                inputs.forEach(input => {
                    input.addEventListener('input', (e) => {
                        const rowToUpdate = state.bulkReplaceRows.find(r => r.id == e.target.dataset.id);
                        if (rowToUpdate) {
                            rowToUpdate[e.target.dataset.field] = e.target.value;
                        }
                    });
                });
                
                const removeBtn = rowDiv.querySelector('.remove-row-btn');
                removeBtn.addEventListener('click', () => removeBulkReplaceRow(row.id));
                
                container.appendChild(rowDiv);
            });
        }

        function removeBulkReplaceRow(rowId) {
            if (state.bulkReplaceRows.length <= 1) {
                showAlert('At least one row is required', 'warning');
                return;
            }
            
            state.bulkReplaceRows = state.bulkReplaceRows.filter(row => row.id !== rowId);
            renderBulkReplaceRows();
        }

        function executeBulkReplace() {
            const editor = document.getElementById('editor');
            if (!editor) {
                showAlert('Please open the editor first', 'error');
                return;
            }

            const caseSensitive = document.getElementById('caseSensitive').checked;
            const wholeWord = document.getElementById('wholeWord').checked;
            const useRegex = document.getElementById('useRegex').checked;

            let text = state.currentContent;
            let totalReplacements = 0;
            const results = [];

            // Filter out empty rows
            const validRows = state.bulkReplaceRows.filter(row => row.find.trim() !== '');

            if (validRows.length === 0) {
                showAlert('Please enter at least one find/replace pair', 'warning');
                return;
            }

            // Process each row
            validRows.forEach((row, index) => {
                let findPattern = row.find;
                let replaceWith = row.replace;
                let count = 0;

                try {
                    let regex;
                    
                    if (useRegex) {
                        // Use as-is if regex mode
                        regex = new RegExp(findPattern, caseSensitive ? 'g' : 'gi');
                    } else {
                        // Escape special characters
                        findPattern = findPattern.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        
                        if (wholeWord) {
                            findPattern = `\\b${findPattern}\\b`;
                        }
                        
                        regex = new RegExp(findPattern, caseSensitive ? 'g' : 'gi');
                    }

                    // Count matches before replacement
                    const matches = text.match(regex);
                    count = matches ? matches.length : 0;

                    if (count > 0) {
                        text = text.replace(regex, replaceWith);
                        totalReplacements += count;
                        results.push({
                            find: row.find,
                            replace: row.replace,
                            count: count
                        });
                    }
                } catch (error) {
                    showAlert(`Error in row ${index + 1}: ${error.message}`, 'error');
                    return;
                }
            });

            if (totalReplacements > 0) {
                state.currentContent = text;
                editor.value = text;
                state.replaceCount += totalReplacements;
                document.getElementById('replaceCount').textContent = state.replaceCount;
                
                addToHistory(`Bulk replaced ${totalReplacements} occurrence(s)`);
                
                // Show results
                displayBulkResults(results, totalReplacements);
                showAlert(`Successfully replaced ${totalReplacements} occurrence(s)!`, 'success');
            } else {
                showAlert('No matches found for any search terms', 'info');
            }
        }

        function displayBulkResults(results, total) {
            const resultsDiv = document.getElementById('bulkResults');
            const contentDiv = document.getElementById('resultsContent');
            
            contentDiv.innerHTML = results.map(r => `
                <div class="result-item">
                    <strong>"${r.find}"</strong> ‚Üí "${r.replace}": ${r.count} replacement${r.count > 1 ? 's' : ''}
                </div>
            `).join('');
            
            contentDiv.innerHTML += `
                <div class="result-item" style="background: #dcfce7; font-weight: 600;">
                    <i class="fas fa-check-circle"></i> Total: ${total} replacement${total > 1 ? 's' : ''}
                </div>
            `;
            
            resultsDiv.classList.add('show');
            
            // Hide after 10 seconds
            setTimeout(() => {
                resultsDiv.classList.remove('show');
            }, 10000);
        }

        function clearBulkReplace() {
            state.bulkReplaceRows = [];
            initializeBulkReplace();
            document.getElementById('caseSensitive').checked = false;
            document.getElementById('wholeWord').checked = false;
            document.getElementById('useRegex').checked = false;
            document.getElementById('bulkResults').classList.remove('show');
            showAlert('Bulk replace cleared', 'info');
        }

        async function handleFileUpload(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            showProgress(30);
            
            try {
                // Reset state
                state.fileType = null;
                state.pdfData = null;
                state.pdfDoc = null;
                state.pdfLibDoc = null;
                
                if (ext === 'html' || ext === 'htm') {
                    await handleHTML(file);
                } else if (ext === 'pdf') {
                    await handlePDF(file);
                } else {
                    showAlert('Please upload HTML or PDF file', 'error');
                    return;
                }
                showProgress(100);
                setTimeout(() => {
                    document.getElementById('uploadProgress').style.width = '0%';
                }, 500);
            } catch (error) {
                console.error('File loading error:', error);
                showAlert(`Error loading file: ${error.message}`, 'error');
                showProgress(0);
            }
        }

        function showProgress(percent) {
            document.getElementById('uploadProgress').style.width = percent + '%';
        }

        async function handleHTML(file) {
            state.fileType = 'html';
            state.fileName = file.name;
            state.originalContent = await file.text();
            state.currentContent = state.originalContent;
            
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileType').textContent = 'HTML';
            document.getElementById('fileSize').textContent = formatSize(file.size);
            document.getElementById('copyBtn').style.display = 'block';
            document.getElementById('pdfEditOptions').classList.add('hidden');
            document.getElementById('bulkReplaceSection').classList.remove('hidden');
            
            resetHistory();
            addToHistory('File loaded');
            setupHTMLTabs();
            showEditor();
            showAlert('HTML loaded successfully!', 'success');
        }

        async function handlePDF(file) {
            state.fileType = 'pdf';
            state.fileName = file.name;
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                const header = new Uint8Array(arrayBuffer.slice(0, 5));
                const headerStr = String.fromCharCode.apply(null, header);
                
                if (!headerStr.startsWith('%PDF-')) {
                    showAlert('Warning: File may not be a valid PDF. Trying to process anyway...', 'warning');
                }
                
                state.pdfData = new Uint8Array(arrayBuffer);
                
                // Load with pdf-lib for editing
                try {
                    state.pdfLibDoc = await PDFLib.PDFDocument.load(state.pdfData, {
                        ignoreEncryption: true,
                        updateMetadata: false
                    });
                    state.pdfPages = state.pdfLibDoc.getPages();
                } catch (pdfLibError) {
                    console.warn('PDF-Lib loading failed:', pdfLibError);
                    state.pdfLibDoc = null;
                }
                
                // Extract text and load for viewing
                let text = '';
                let numPages = 0;
                
                try {
                    const loadingTask = pdfjsLib.getDocument({ 
                        data: state.pdfData,
                        disableAutoFetch: true,
                        disableStream: true,
                        verbosity: 0
                    });
                    
                    state.pdfDoc = await loadingTask.promise;
                    numPages = state.pdfDoc.numPages;
                    
                    // Extract text from all pages
                    for (let i = 1; i <= numPages; i++) {
                        try {
                            const page = await state.pdfDoc.getPage(i);
                            const content = await page.getTextContent();
                            
                            // Store text content with position info
                            state.pdfTextLayers.push({
                                pageNum: i,
                                items: content.items
                            });
                            
                            text += `--- Page ${i} ---\n`;
                            text += content.items.map(item => item.str).join(' ') + '\n\n';
                        } catch (pageError) {
                            console.warn(`Error extracting text from page ${i}:`, pageError);
                            text += `[Page ${i} - Text extraction failed]\n\n`;
                        }
                    }
                } catch (pdfjsError) {
                    console.warn('PDF.js loading failed, using fallback:', pdfjsError);
                    text = extractTextFromBinary(state.pdfData);
                    numPages = 1;
                    showAlert('PDF loaded in text-only mode', 'warning');
                }
                
                state.originalContent = text;
                state.currentContent = text;
                
                document.getElementById('fileName').textContent = file.name;
                document.getElementById('fileType').textContent = 'PDF';
                document.getElementById('fileSize').textContent = formatSize(file.size);
                document.getElementById('copyBtn').style.display = 'none';
                document.getElementById('pdfEditOptions').classList.remove('hidden');
                document.getElementById('bulkReplaceSection').classList.remove('hidden');
                
                const pdfModeRadio = document.querySelector(`input[name="pdfMode"][value="${state.pdfDoc ? 'full' : 'text'}"]`);
                if (pdfModeRadio) {
                    pdfModeRadio.checked = true;
                    state.pdfMode = state.pdfDoc ? 'full' : 'text';
                }
                
                resetHistory();
                addToHistory('PDF loaded');
                setupPDFTabs();
                showEditor();
                
                const message = state.pdfDoc 
                    ? `PDF loaded! ${numPages} pages available`
                    : 'PDF loaded in text-only mode';
                showAlert(message, 'success');
                
            } catch (error) {
                console.error('PDF handling error:', error);
                throw new Error(`Failed to process PDF: ${error.message}`);
            }
        }

        function extractTextFromBinary(data) {
            let text = '';
            const decoder = new TextDecoder('utf-8', { fatal: false });
            
            const chunkSize = 4096;
            for (let i = 0; i < data.length; i += chunkSize) {
                const chunk = data.slice(i, i + chunkSize);
                const chunkText = decoder.decode(chunk);
                
                const matches = chunkText.match(/\(([^)]+)\)/g);
                if (matches) {
                    matches.forEach(match => {
                        text += match.slice(1, -1) + ' ';
                    });
                }
                
                const words = chunkText.match(/[a-zA-Z0-9.,!?;:'"\s]{4,}/g);
                if (words) {
                    text += words.join(' ') + ' ';
                }
            }
            
            return text || 'No text could be extracted from the PDF.';
        }

        async function reprocessPdf() {
            if (!state.pdfData) {
                showAlert('No PDF data to reprocess', 'error');
                return;
            }
            
            showProgress(50);
            try {
                if (state.pdfMode === 'full') {
                    const loadingTask = pdfjsLib.getDocument({ 
                        data: state.pdfData,
                        disableAutoFetch: true,
                        disableStream: true
                    });
                    state.pdfDoc = await loadingTask.promise;
                    showAlert(`PDF reloaded! ${state.pdfDoc.numPages} pages`, 'success');
                } else {
                    state.pdfDoc = null;
                    showAlert('Switched to text-only mode', 'info');
                }
                
                if (document.querySelector('.tab.active[data-tab="preview"]')) {
                    await showPDFPreview();
                }
                
                showProgress(100);
                setTimeout(() => {
                    document.getElementById('uploadProgress').style.width = '0%';
                }, 500);
            } catch (error) {
                showAlert(`Failed to reprocess PDF: ${error.message}`, 'error');
                showProgress(0);
            }
        }

        function setupHTMLTabs() {
            const tabs = document.getElementById('tabs');
            tabs.innerHTML = `
                <button class="tab active" data-tab="edit">
                    <i class="fas fa-code"></i> Edit Code
                </button>
                <button class="tab" data-tab="preview">
                    <i class="fas fa-eye"></i> Preview
                </button>
                <button class="tab" data-tab="source">
                    <i class="fas fa-file-code"></i> Source View
                </button>
            `;
            
            setupToolbar('html');
            
            tabs.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    switch(tab.dataset.tab) {
                        case 'edit':
                            showHTMLEditor();
                            break;
                        case 'preview':
                            showHTMLPreview();
                            break;
                        case 'source':
                            showHTMLSource();
                            break;
                    }
                });
            });
            
            showHTMLEditor();
        }

        function setupPDFTabs() {
            const tabs = document.getElementById('tabs');
            
            if (state.pdfDoc) {
                tabs.innerHTML = `
                    <button class="tab active" data-tab="edit">
                        <i class="fas fa-edit"></i> Edit Text
                    </button>
                    <button class="tab" data-tab="preview">
                        <i class="fas fa-file-pdf"></i> View PDF
                    </button>
                    <button class="tab" data-tab="annotate">
                        <i class="fas fa-draw-polygon"></i> Annotate
                    </button>
                `;
            } else {
                tabs.innerHTML = `
                    <button class="tab active" data-tab="edit">
                        <i class="fas fa-edit"></i> Edit Text
                    </button>
                    <button class="tab" data-tab="info" disabled title="PDF preview not available">
                        <i class="fas fa-eye-slash"></i> Preview (N/A)
                    </button>
                `;
            }
            
            setupToolbar('pdf');
            
            tabs.querySelectorAll('.tab:not([disabled])').forEach(tab => {
                tab.addEventListener('click', () => {
                    tabs.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    switch(tab.dataset.tab) {
                        case 'edit':
                            showPDFEditor();
                            break;
                        case 'preview':
                            showPDFPreview();
                            break;
                        case 'annotate':
                            showPDFAnnotation();
                            break;
                    }
                });
            });
            
            showPDFEditor();
        }

        function setupToolbar(type) {
            const toolbar = document.getElementById('editorToolbar');
            
            if (type === 'html') {
                toolbar.innerHTML = `
                    <button onclick="formatText('bold')" title="Bold (Ctrl+B)"><i class="fas fa-bold"></i></button>
                    <button onclick="formatText('italic')" title="Italic (Ctrl+I)"><i class="fas fa-italic"></i></button>
                    <button onclick="formatText('underline')" title="Underline (Ctrl+U)"><i class="fas fa-underline"></i></button>
                    <div style="width:1px; background:#e5e7eb; margin:0 10px;"></div>
                    <button onclick="insertTag('<h1>', '</h1>')"><i class="fas fa-heading"></i> H1</button>
                    <button onclick="insertTag('<p>', '</p>')"><i class="fas fa-paragraph"></i> P</button>
                    <button onclick="insertTag('<a href=\\\"\\\">', '</a>')"><i class="fas fa-link"></i> Link</button>
                    <button onclick="insertTag('<img src=\\\"\\\" alt=\\\"\\\">', '')"><i class="fas fa-image"></i> Image</button>
                `;
            } else {
                if (state.pdfDoc) {
                    toolbar.innerHTML = `
                        <button onclick="highlightText()" title="Highlight selected text"><i class="fas fa-highlighter"></i> Highlight</button>
                        <button onclick="addComment()" title="Add comment"><i class="fas fa-comment"></i> Comment</button>
                        <button onclick="drawRectangle()" title="Draw rectangle"><i class="fas fa-square"></i> Rectangle</button>
                        <button onclick="drawCircle()" title="Draw circle"><i class="fas fa-circle"></i> Circle</button>
                        <button onclick="addStamp()" title="Add stamp"><i class="fas fa-stamp"></i> Stamp</button>
                    `;
                } else {
                    toolbar.innerHTML = `
                        <button disabled title="PDF tools not available"><i class="fas fa-highlighter"></i></button>
                        <button disabled title="PDF tools not available"><i class="fas fa-comment"></i></button>
                        <span style="color: #6b7280; font-size: 14px; padding: 10px;">PDF preview not available - text editing only</span>
                    `;
                }
            }
        }

        function showHTMLEditor() {
            const content = document.getElementById('contentArea');
            content.innerHTML = '<textarea class="text-editor" id="editor"></textarea>';
            const editor = document.getElementById('editor');
            editor.value = state.currentContent;
            
            editor.addEventListener('input', (e) => {
                const oldContent = state.currentContent;
                state.currentContent = e.target.value;
                if (oldContent !== state.currentContent) {
                    addToHistory('Text edited');
                }
            });
            
            editor.addEventListener('select', () => {
                state.selection = {
                    start: editor.selectionStart,
                    end: editor.selectionEnd,
                    text: editor.value.substring(editor.selectionStart, editor.selectionEnd)
                };
            });
            
            editor.focus();
        }

        function showHTMLPreview() {
            const content = document.getElementById('contentArea');
            content.innerHTML = '<div class="html-preview"><iframe id="previewFrame"></iframe></div>';
            const iframe = document.getElementById('previewFrame');
            iframe.srcdoc = state.currentContent;
        }

        function showHTMLSource() {
            const content = document.getElementById('contentArea');
            content.innerHTML = `
                <div style="display: flex; gap: 20px;">
                    <div style="flex: 1;">
                        <h3 style="margin-bottom: 10px;">Original</h3>
                        <textarea class="text-editor" style="min-height: 600px; background: #fef2f2;" readonly>${state.originalContent}</textarea>
                    </div>
                    <div style="flex: 1;">
                        <h3 style="margin-bottom: 10px;">Edited</h3>
                        <textarea class="text-editor" style="min-height: 600px; background: #f0fdf4;">${state.currentContent}</textarea>
                    </div>
                </div>
            `;
        }

        function showPDFEditor() {
            const content = document.getElementById('contentArea');
            content.innerHTML = '<textarea class="text-editor" id="editor" placeholder="Edit extracted PDF text here..."></textarea>';
            const editor = document.getElementById('editor');
            editor.value = state.currentContent;
            
            editor.addEventListener('input', (e) => {
                const oldContent = state.currentContent;
                state.currentContent = e.target.value;
                if (oldContent !== state.currentContent) {
                    addToHistory('PDF text edited');
                    state.isPdfModified = true;
                }
            });
            
            editor.focus();
        }

        async function showPDFPreview() {
            if (!state.pdfDoc) {
                const content = document.getElementById('contentArea');
                content.innerHTML = `
                    <div style="text-align: center; padding: 50px;">
                        <i class="fas fa-exclamation-triangle" style="font-size: 48px; color: #f59e0b; margin-bottom: 20px;"></i>
                        <h3 style="color: #92400e; margin-bottom: 10px;">PDF Preview Not Available</h3>
                        <p style="color: #6b7280; margin-bottom: 20px;">The PDF could not be loaded for preview. You can still edit the extracted text.</p>
                        <button onclick="reprocessPdf()" class="warning">
                            <i class="fas fa-redo"></i> Try Reloading PDF
                        </button>
                    </div>
                `;
                return;
            }
            
            const content = document.getElementById('contentArea');
            content.innerHTML = '<div class="pdf-preview" id="pdfPreview"></div>';
            const container = document.getElementById('pdfPreview');
            container.innerHTML = '';
            
            try {
                for (let i = 1; i <= state.pdfDoc.numPages; i++) {
                    const page = await state.pdfDoc.getPage(i);
                    const viewport = page.getViewport({scale: 1.5});
                    
                    const pageDiv = document.createElement('div');
                    pageDiv.className = 'pdf-page';
                    pageDiv.dataset.page = i;
                    pageDiv.style.position = 'relative';
                    
                    const pageNumber = document.createElement('div');
                    pageNumber.className = 'page-number';
                    pageNumber.textContent = `Page ${i}`;
                    pageDiv.appendChild(pageNumber);
                    
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    canvas.height = viewport.height;
                    canvas.width = viewport.width;
                    
                    await page.render({
                        canvasContext: context,
                        viewport: viewport
                    }).promise;
                    
                    pageDiv.appendChild(canvas);
                    container.appendChild(pageDiv);
                }
                
                showAlert('PDF rendered successfully', 'success');
            } catch (error) {
                console.error('Error rendering PDF:', error);
                container.innerHTML = `
                    <div style="text-align: center; padding: 50px; color: #dc2626;">
                        <i class="fas fa-exclamation-circle" style="font-size: 48px; margin-bottom: 20px;"></i>
                        <h3>Error rendering PDF preview</h3>
                        <p>${error.message}</p>
                        <button onclick="reprocessPdf()" class="warning" style="margin-top: 20px;">
                            <i class="fas fa-redo"></i> Try Again
                        </button>
                    </div>
                `;
            }
        }

        function showPDFAnnotation() {
            if (!state.pdfDoc) {
                showAlert('PDF preview not available for annotation', 'error');
                return;
            }
            
            showPDFPreview().then(() => {
                const pages = document.querySelectorAll('.pdf-page');
                pages.forEach(page => {
                    page.style.cursor = 'crosshair';
                    page.addEventListener('click', (e) => {
                        const rect = page.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        
                        addAnnotation(page, x, y);
                    });
                });
                showAlert('Click on PDF to add annotations', 'info');
            });
        }

        function addAnnotation(pageElement, x, y) {
            const annotation = document.createElement('div');
            annotation.className = 'pdf-annotation';
            annotation.style.left = x + 'px';
            annotation.style.top = y + 'px';
            annotation.style.width = '200px';
            annotation.style.height = '100px';
            
            const textarea = document.createElement('textarea');
            textarea.style.width = '100%';
            textarea.style.height = '100%';
            textarea.style.border = 'none';
            textarea.style.background = 'transparent';
            textarea.style.resize = 'none';
            textarea.placeholder = 'Type annotation here...';
            
            annotation.appendChild(textarea);
            pageElement.appendChild(annotation);
            
            makeDraggable(annotation);
            
            state.pdfAnnotations.push({
                element: annotation,
                page: parseInt(pageElement.dataset.page),
                x,
                y
            });
            
            addToHistory('Annotation added');
            textarea.focus();
        }

        function makeDraggable(element) {
            let isDragging = false;
            let offsetX, offsetY;
            
            element.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'TEXTAREA') return;
                
                isDragging = true;
                offsetX = e.clientX - element.getBoundingClientRect().left;
                offsetY = e.clientY - element.getBoundingClientRect().top;
                element.classList.add('selected');
                
                document.addEventListener('mousemove', mouseMove);
                document.addEventListener('mouseup', mouseUp);
                
                e.preventDefault();
            });
            
            function mouseMove(e) {
                if (isDragging) {
                    const parentRect = element.parentElement.getBoundingClientRect();
                    const x = e.clientX - parentRect.left - offsetX;
                    const y = e.clientY - parentRect.top - offsetY;
                    
                    element.style.left = Math.max(0, Math.min(parentRect.width - element.offsetWidth, x)) + 'px';
                    element.style.top = Math.max(0, Math.min(parentRect.height - element.offsetHeight, y)) + 'px';
                }
            }
            
            function mouseUp() {
                isDragging = false;
                element.classList.remove('selected');
                document.removeEventListener('mousemove', mouseMove);
                document.removeEventListener('mouseup', mouseUp);
                
                const annotation = state.pdfAnnotations.find(a => a.element === element);
                if (annotation) {
                    annotation.x = parseInt(element.style.left);
                    annotation.y = parseInt(element.style.top);
                    addToHistory('Annotation moved');
                }
            }
        }

        function showEditor() {
            document.getElementById('editorGrid').classList.remove('hidden');
        }

        // History management
        function resetHistory() {
            state.history = [];
            state.historyIndex = -1;
            updateHistoryUI();
        }

        function addToHistory(action) {
            if (state.historyIndex < state.history.length - 1) {
                state.history = state.history.slice(0, state.historyIndex + 1);
            }
            
            state.history.push({
                content: state.currentContent,
                action: action,
                timestamp: new Date().toLocaleTimeString()
            });
            
            state.historyIndex = state.history.length - 1;
            state.lastAction = action;
            
            updateHistoryUI();
            document.getElementById('lastAction').textContent = action;
        }

        function undo() {
            if (state.historyIndex > 0) {
                state.historyIndex--;
                const historyItem = state.history[state.historyIndex];
                state.currentContent = historyItem.content;
                
                const editor = document.getElementById('editor');
                if (editor) {
                    editor.value = state.currentContent;
                }
                
                updateHistoryUI();
                state.lastAction = `Undo: ${historyItem.action}`;
                document.getElementById('lastAction').textContent = state.lastAction;
                
                showAlert(`Undo: ${historyItem.action}`, 'info');
            }
        }

        function redo() {
            if (state.historyIndex < state.history.length - 1) {
                state.historyIndex++;
                const historyItem = state.history[state.historyIndex];
                state.currentContent = historyItem.content;
                
                const editor = document.getElementById('editor');
                if (editor) {
                    editor.value = state.currentContent;
                }
                
                updateHistoryUI();
                state.lastAction = `Redo: ${historyItem.action}`;
                document.getElementById('lastAction').textContent = state.lastAction;
                
                showAlert(`Redo: ${historyItem.action}`, 'info');
            }
        }

        function updateHistoryUI() {
            document.getElementById('historyCount').textContent = 
                `${state.historyIndex + 1}/${state.history.length}`;
            
            document.getElementById('undoBtn').disabled = state.historyIndex <= 0;
            document.getElementById('redoBtn').disabled = state.historyIndex >= state.history.length - 1;
            
            const historyInfo = document.getElementById('historyInfo');
            if (state.history.length > 0) {
                const current = state.history[state.historyIndex];
                historyInfo.textContent = `${current.action} at ${current.timestamp}`;
            } else {
                historyInfo.textContent = 'No actions performed yet';
            }
        }

        // Text editing functions
        function findText() {
            const find = document.getElementById('findInput').value;
            if (!find) return;
            
            const editor = document.getElementById('editor');
            if (!editor) return;
            
            const text = editor.value;
            const regex = new RegExp(find.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            const matches = text.match(regex);
            
            if (matches) {
                editor.focus();
                const firstIndex = text.toLowerCase().indexOf(find.toLowerCase());
                if (firstIndex !== -1) {
                    editor.setSelectionRange(firstIndex, firstIndex + find.length);
                }
                showAlert(`Found ${matches.length} match(es)`, 'info');
            } else {
                showAlert('No matches found', 'warning');
            }
        }

        function replaceText() {
            const find = document.getElementById('findInput').value;
            const replace = document.getElementById('replaceInput').value;
            const scope = document.getElementById('replaceScope').value;
            
            if (!find) {
                showAlert('Enter text to find', 'error');
                return;
            }
            
            const editor = document.getElementById('editor');
            if (!editor) return;
            
            let text = editor.value;
            let regex;
            
            if (scope === 'case') {
                regex = new RegExp(find.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
            } else {
                regex = new RegExp(find.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
            }
            
            let newText;
            let count = 0;
            
            if (scope === 'selection' && state.selection) {
                const selectedText = state.selection.text;
                newText = selectedText.replace(regex, replace);
                count = (selectedText.match(regex) || []).length;
                
                text = text.substring(0, state.selection.start) + 
                       newText + 
                       text.substring(state.selection.end);
            } else {
                const matches = text.match(regex);
                count = matches ? matches.length : 0;
                newText = text.replace(regex, replace);
            }
            
            if (count === 0) {
                showAlert('No matches found', 'info');
                return;
            }
            
            state.currentContent = newText;
            editor.value = newText;
            
            state.replaceCount += count;
            document.getElementById('replaceCount').textContent = state.replaceCount;
            
            addToHistory(`Replaced ${count} occurrence(s)`);
            showAlert(`Replaced ${count} occurrence(s)!`, 'success');
        }

        function clearFields() {
            document.getElementById('findInput').value = '';
            document.getElementById('replaceInput').value = '';
            showAlert('Fields cleared', 'info');
        }

        // PDF editing functions
        async function addTextToPdf() {
            if (!state.pdfLibDoc) {
                showAlert('PDF editing not available for this file', 'error');
                return;
            }
            
            const text = prompt('Enter text to add to PDF:', 'Sample Text');
            if (!text) return;
            
            const pageNum = prompt('Enter page number (1-' + state.pdfPages.length + '):', '1');
            const pageIndex = parseInt(pageNum) - 1;
            
            if (pageIndex < 0 || pageIndex >= state.pdfPages.length) {
                showAlert('Invalid page number', 'error');
                return;
            }
            
            try {
                const page = state.pdfPages[pageIndex];
                const { width, height } = page.getSize();
                
                const fontSize = parseInt(prompt('Enter font size:', '12')) || 12;
                const x = parseInt(prompt('Enter X position (0-' + Math.floor(width) + '):', '50')) || 50;
                const y = parseInt(prompt('Enter Y position from bottom (0-' + Math.floor(height) + '):', '100')) || 100;
                
                page.drawText(text, {
                    x: x,
                    y: height - y,
                    size: fontSize,
                    color: PDFLib.rgb(0, 0, 0),
                });
                
                state.isPdfModified = true;
                addToHistory(`Text added to page ${pageNum}`);
                showAlert('Text added to PDF! Click "Save PDF Edits" to download', 'success');
            } catch (error) {
                showAlert(`Error adding text: ${error.message}`, 'error');
            }
        }

        async function addImageToPdf() {
            if (!state.pdfLibDoc) {
                showAlert('PDF editing not available for this file', 'error');
                return;
            }
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/png,image/jpeg,image/jpg';
            
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const pageNum = prompt('Enter page number (1-' + state.pdfPages.length + '):', '1');
                    const pageIndex = parseInt(pageNum) - 1;
                    
                    if (pageIndex < 0 || pageIndex >= state.pdfPages.length) {
                        showAlert('Invalid page number', 'error');
                        return;
                    }
                    
                    const page = state.pdfPages[pageIndex];
                    const { width, height } = page.getSize();
                    
                    let image;
                    if (file.type === 'image/png') {
                        image = await state.pdfLibDoc.embedPng(arrayBuffer);
                    } else {
                        image = await state.pdfLibDoc.embedJpg(arrayBuffer);
                    }
                    
                    const imgWidth = parseInt(prompt('Enter image width:', '200')) || 200;
                    const imgHeight = parseInt(prompt('Enter image height:', '150')) || 150;
                    const x = parseInt(prompt('Enter X position:', '50')) || 50;
                    const y = parseInt(prompt('Enter Y position from bottom:', '100')) || 100;
                    
                    page.drawImage(image, {
                        x: x,
                        y: height - y - imgHeight,
                        width: imgWidth,
                        height: imgHeight,
                    });
                    
                    state.isPdfModified = true;
                    addToHistory(`Image added to page ${pageNum}`);
                    showAlert('Image added to PDF! Click "Save PDF Edits" to download', 'success');
                } catch (error) {
                    showAlert(`Error adding image: ${error.message}`, 'error');
                }
            };
            
            input.click();
        }

        async function savePdfEdits() {
            if (!state.isPdfModified && state.pdfAnnotations.length === 0) {
                showAlert('No changes to save', 'info');
                return;
            }
            
            showProgress(30);
            
            try {
                let pdfBytes;
                
                if (state.pdfLibDoc && state.isPdfModified) {
                    // Save actual PDF edits
                    pdfBytes = await state.pdfLibDoc.save();
                    showProgress(70);
                } else {
                    // Create new PDF with edited text
                    const newPdfDoc = await PDFLib.PDFDocument.create();
                    const lines = state.currentContent.split('\n');
                    let currentPage = newPdfDoc.addPage([600, 800]);
                    let yPosition = 750;
                    
                    for (const line of lines) {
                        if (yPosition < 50) {
                            currentPage = newPdfDoc.addPage([600, 800]);
                            yPosition = 750;
                        }
                        
                        if (line.trim()) {
                            currentPage.drawText(line, {
                                x: 50,
                                y: yPosition,
                                size: 12,
                                maxWidth: 500,
                            });
                            yPosition -= 20;
                        } else {
                            yPosition -= 10;
                        }
                    }
                    
                    pdfBytes = await newPdfDoc.save();
                    showProgress(70);
                }
                
                const blob = new Blob([pdfBytes], {type: 'application/pdf'});
                download(blob, state.fileName.replace('.pdf', '_edited.pdf'));
                
                addToHistory('PDF saved with edits');
                state.isPdfModified = false;
                
                showProgress(100);
                setTimeout(() => {
                    document.getElementById('uploadProgress').style.width = '0%';
                }, 500);
                
                showAlert('PDF saved successfully!', 'success');
            } catch (error) {
                console.error('Save error:', error);
                showAlert(`Error saving PDF: ${error.message}`, 'error');
                showProgress(0);
            }
        }

        // Utility functions
        function downloadFile() {
            if (state.fileType === 'html') {
                const blob = new Blob([state.currentContent], {type: 'text/html'});
                download(blob, state.fileName.replace(/\.(html|htm)$/, '_edited.html'));
                showAlert('HTML downloaded!', 'success');
            } else if (state.fileType === 'pdf') {
                if (state.isPdfModified || state.pdfAnnotations.length > 0) {
                    if (confirm('You have unsaved PDF edits. Save them before downloading?')) {
                        savePdfEdits();
                    } else {
                        const blob = new Blob([state.currentContent], {type: 'text/plain'});
                        download(blob, state.fileName.replace('.pdf', '_extracted.txt'));
                        showAlert('Text file downloaded!', 'info');
                    }
                } else {
                    const blob = new Blob([state.currentContent], {type: 'text/plain'});
                    download(blob, state.fileName.replace('.pdf', '_extracted.txt'));
                    showAlert('Text file downloaded!', 'info');
                }
            }
        }

        async function copyToClipboard() {
            try {
                await navigator.clipboard.writeText(state.currentContent);
                showAlert('Content copied to clipboard!', 'success');
            } catch (e) {
                showAlert('Failed to copy', 'error');
            }
        }

        function resetEditor() {
            if (confirm('Are you sure you want to reset the editor? All unsaved changes will be lost.')) {
                state.currentContent = state.originalContent;
                state.replaceCount = 0;
                state.isPdfModified = false;
                state.pdfAnnotations = [];
                
                const editor = document.getElementById('editor');
                if (editor) {
                    editor.value = state.currentContent;
                }
                
                document.getElementById('replaceCount').textContent = '0';
                document.getElementById('lastAction').textContent = '-';
                
                // Clear bulk replace results
                document.getElementById('bulkResults').classList.remove('show');
                
                resetHistory();
                showAlert('Editor reset to original state', 'info');
            }
        }

        function download(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function showAlert(message, type) {
            const alert = document.createElement('div');
            alert.className = `alert ${type}`;
            
            const icons = {
                success: 'fa-check-circle',
                error: 'fa-exclamation-circle',
                info: 'fa-info-circle',
                warning: 'fa-exclamation-triangle'
            };
            
            alert.innerHTML = `
                <i class="fas ${icons[type]}"></i>
                <span>${message}</span>
            `;
            
            document.body.appendChild(alert);
            setTimeout(() => {
                alert.style.animation = 'slideIn 0.3s reverse';
                setTimeout(() => alert.remove(), 300);
            }, 3000);
        }

        // HTML formatting functions
        function formatText(format) {
            const editor = document.getElementById('editor');
            if (!editor) return;
            
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            const selectedText = editor.value.substring(start, end);
            
            if (!selectedText) {
                showAlert('Please select text first', 'warning');
                return;
            }
            
            let formattedText;
            switch(format) {
                case 'bold':
                    formattedText = `<strong>${selectedText}</strong>`;
                    break;
                case 'italic':
                    formattedText = `<em>${selectedText}</em>`;
                    break;
                case 'underline':
                    formattedText = `<u>${selectedText}</u>`;
                    break;
                default:
                    return;
            }
            
            const newText = editor.value.substring(0, start) + 
                           formattedText + 
                           editor.value.substring(end);
            
            state.currentContent = newText;
            editor.value = newText;
            addToHistory(`Formatted text as ${format}`);
            
            // Maintain cursor position
            editor.focus();
            editor.setSelectionRange(start, start + formattedText.length);
        }

        function insertTag(startTag, endTag) {
            const editor = document.getElementById('editor');
            if (!editor) return;
            
            const start = editor.selectionStart;
            const end = editor.selectionEnd;
            const selectedText = editor.value.substring(start, end);
            
            const newText = editor.value.substring(0, start) + 
                           startTag + selectedText + endTag + 
                           editor.value.substring(end);
            
            state.currentContent = newText;
            editor.value = newText;
            addToHistory(`Inserted ${startTag} tag`);
            
            // Position cursor inside the tags
            const cursorPos = start + startTag.length;
            editor.focus();
            editor.setSelectionRange(cursorPos, cursorPos + selectedText.length);
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // PDF annotation functions
        function highlightText() {
            showAlert('Select text on PDF and click to highlight', 'info');
        }

        function addComment() {
            showAlert('Click on PDF to add comment', 'info');
        }

        function drawRectangle() {
            showAlert('Click and drag on PDF to draw rectangle', 'info');
        }

        function drawCircle() {
            showAlert('Click and drag on PDF to draw circle', 'info');
        }

        function addStamp() {
            const stamps = ['APPROVED', 'CONFIDENTIAL', 'DRAFT', 'URGENT', 'REVIEWED', 'FINAL'];
            const stamp = prompt('Enter stamp text or choose from: ' + stamps.join(', '), stamps[0]);
            
            if (!stamp) return;
            
            if (!state.pdfLibDoc) {
                showAlert('PDF editing not available', 'error');
                return;
            }
            
            const pageNum = prompt('Enter page number (1-' + state.pdfPages.length + '):', '1');
            const pageIndex = parseInt(pageNum) - 1;
            
            if (pageIndex < 0 || pageIndex >= state.pdfPages.length) {
                showAlert('Invalid page number', 'error');
                return;
            }
            
            try {
                const page = state.pdfPages[pageIndex];
                const { width, height } = page.getSize();
                
                page.drawText(stamp.toUpperCase(), {
                    x: width / 2 - 50,
                    y: height / 2,
                    size: 24,
                    color: PDFLib.rgb(0.8, 0.2, 0.2),
                    opacity: 0.5,
                    rotate: PDFLib.degrees(-45)
                });
                
                state.isPdfModified = true;
                addToHistory(`Added ${stamp} stamp to page ${pageNum}`);
                showAlert(`${stamp} stamp added! Click "Save PDF Edits" to download`, 'success');
            } catch (error) {
                showAlert(`Error adding stamp: ${error.message}`, 'error');
            }
        }
    </script>
</body>
</html>
